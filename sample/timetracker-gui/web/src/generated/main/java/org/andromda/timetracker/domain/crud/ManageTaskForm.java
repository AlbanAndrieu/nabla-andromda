// license-header java merge-point
// Generated by andromda-jsf cartridge (forms\crud\Form.java.vsl) DO NOT EDIT!
package org.andromda.timetracker.domain.crud;

import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.faces.application.FacesMessage;

/**
 * This class represents a task for which time allocations need to be tracked.
 * This form encapsulates the fields that are used in the execution of the CRUD operations in Task
 */
public class ManageTaskForm
    implements Serializable
{
    /**
     * Default constructor. Initializes the attribute formatters.
     */
    public ManageTaskForm(){
        // - setup the default java.util.Date.toString() formatter
        DateFormat dateFormatter = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");
        dateFormatter.setLenient(true);
        this.dateTimeFormatters.put(null, dateFormatter);

        this.searchForm = new ManageTaskSearchForm();

        this.editState=false;
    }

    /**
     * Holds the edit/search state of the form
     */
    private boolean editState;

    /**
     * @return editState
     */
    public boolean getEditState(){
        return this.editState;
    }

    /**
     * @param editStateIn
     */
    public void setEditState(boolean editStateIn){
        this.editState = editStateIn;
    }

    private ManageTaskSearchForm searchForm;

    /**
     * @return searchForm
     */
    public ManageTaskSearchForm getSearchForm(){
        return this.searchForm;
    }

    /**
     * @param searchFormIn
     */
    public void setSearchForm(ManageTaskSearchForm searchFormIn){
        this.searchForm = searchFormIn;
    }

    private List manageableList = null;

    /**
     * @return manageableList
     */
    public List getManageableList()
    {
        return this.manageableList;
    }

    /**
     * @param manageableListIn
     */
    public void setManageableList(List manageableListIn)
    {
        this.manageableList = manageableListIn;
    }

    private Long[] selectedRows = null;

    /**
     * @return selectedRows
     */
    public Long[] getSelectedRows()
    {
        return this.selectedRows;
    }

    /**
     * @param selectedRowsIn
     */
    public void setSelectedRows(Long[] selectedRowsIn)
    {
        this.selectedRows = selectedRowsIn;
    }

    private String name;

    /**
     * TODO: Model Documentation for org.andromda.timetracker.domain.Task.name
     * @return name
     */
    public String getName()
    {
        return this.name;
    }

    /**
     * TODO: Model Documentation for org.andromda.timetracker.domain.Task.name
     * @param nameIn
     */
    public void setName(String nameIn)
    {
        this.name = nameIn;
    }

    private Collection<?> nameBackingList;

    /**
     * @return nameBackingList
     */
    public Collection<?> getNameBackingList(){
        return this.nameBackingList;
    }

    /**
     * @param nameBackingListIn
     */
    public void setNameBackingList(Collection<?> nameBackingListIn){
        this.nameBackingList = nameBackingListIn;
    }

    private Long id;

    /**
     * TODO: Model Documentation for org.andromda.timetracker.domain.Task.id
     * @return id
     */
    public Long getId()
    {
        return this.id;
    }

    /**
     * TODO: Model Documentation for org.andromda.timetracker.domain.Task.id
     * @param idIn
     */
    public void setId(Long idIn)
    {
        this.id = idIn;
    }

    private Collection<?> idBackingList;

    /**
     * @return idBackingList
     */
    public Collection<?> getIdBackingList(){
        return this.idBackingList;
    }

    /**
     * @param idBackingListIn
     */
    public void setIdBackingList(Collection<?> idBackingListIn){
        this.idBackingList = idBackingListIn;
    }

    /**
     * Stores any date or time formatters for this form.
     */
    private final Map<String,DateFormat> dateTimeFormatters = new HashMap<String,DateFormat>();

    /**
     * Gets any date and time formatters (keyed by property name)
     * for this form.
     *
     * @return the Map containing any date and time formatters.
     */
    public Map<String,DateFormat> getDateTimeFormatters()
    {
        return this.dateTimeFormatters;
    }

    /**
     * The current collection of messages stored within this form.
     */
    private Map<String, FacesMessage> jsfMessages =
        new LinkedHashMap<String, FacesMessage>();

    /**
     * Adds a {@link FacesMessage} message to the current messages
     * stored within this form.
     *
     * @param jsfMessage the faces message to add.
     */
    public void addJsfMessages(FacesMessage jsfMessage)
    {
        if (jsfMessage != null)
        {
            this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
        }
    }

    /**
     * Gets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @return the current Faces messages.
     */
    public Collection<FacesMessage> getJsfMessages()
    {
        return this.jsfMessages.values();
    }

    /**
     * Sets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @param messages a collection of the current Faces messages.
     */
    public void setJsfMessages(final Collection<FacesMessage> messages)
    {
        if (messages != null)
        {
            for (final FacesMessage jsfMessage : messages)
            {
                this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
            }
        }
    }

    /**
     * Clear the current {@link FacesMessage} message
     * instances stored within this form.
     */
    public void clearJsfMessages()
    {
        this.jsfMessages.clear();
    }

    /**
     * The faces message title (used on a view).
     */
    private String jsfMessagesTitle;

    /**
     * The optional faces message title to set (used on a view).  If not set, the default title
     * will be used.
     *
     * @param jsfMessagesTitleIn the title to use for the messages on the view.
     */
    public void setJsfMessagesTitle(final String jsfMessagesTitleIn)
    {
        this.jsfMessagesTitle = jsfMessagesTitleIn;
    }

    /**
     * Gets the faces messages title to use.
     *
     * @return the faces messages title.
     */
    public String getJsfMessagesTitle()
    {
        return this.jsfMessagesTitle;
    }

    /**
     * Gets the maximum severity of the messages stored in this form.
     *
     * @return the maximum severity or null if no messages are present and/or severity isn't set.
     */
    public FacesMessage.Severity getMaximumMessageSeverity()
    {
        FacesMessage.Severity maxSeverity = null;
        for (final FacesMessage message : this.getJsfMessages())
        {
            final FacesMessage.Severity severity = message.getSeverity();
            if (maxSeverity == null || (severity != null && severity.getOrdinal() > maxSeverity.getOrdinal()))
            {
                maxSeverity = severity;
            }
        }
        return maxSeverity;
    }

    /**
     * Copy all the properties from the other form to the current form.
     *
     * @param otherForm the form with the source properties to be copied.
     */
    public void copyFrom(ManageTaskForm otherForm){
        this.setName(otherForm.getName());
        this.setNameBackingList(otherForm.getNameBackingList());
        this.setId(otherForm.getId());
        this.setIdBackingList(otherForm.getIdBackingList());

        this.setJsfMessages(otherForm.getJsfMessages());
        this.setJsfMessagesTitle(otherForm.getJsfMessagesTitle());

        this.setEditState(otherForm.getEditState());
        this.setSearchForm(otherForm.getSearchForm());
        this.setManageableList(otherForm.getManageableList());
        this.setSelectedRows(otherForm.getSelectedRows());
    }

    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = 5857395696087052279L;
}