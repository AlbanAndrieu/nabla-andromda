// license-header java merge-point
// Generated by andromda-jsf cartridge (controllers\crud\Controller.java.vsl) DO NOT EDIT!
package org.andromda.timetracker.domain.crud;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import javax.faces.component.UIParameter;
import javax.faces.event.ActionEvent;
import javax.faces.model.SelectItem;
import org.andromda.presentation.gui.ControllerBase;
import org.andromda.presentation.gui.Messages;
import org.andromda.presentation.gui.PatternMatchingExceptionHandler;
import org.andromda.timetracker.ManageableServiceLocator;
import org.apache.commons.lang.ObjectUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Java Server Faces Controller of the User CRUD management.
 */
public abstract class UserController
    extends ControllerBase
{
    private static final Log logger = LogFactory.getLog(UserController.class);

    /**
     * Initializes the controller, calling the doInit method
     *
     * @return the controller view path.
     */
    public String init()
    {
        this.resetUseCaseFormsAndPageVariables();

        try
        {
            final ManageUserForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doInit(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }
        return "/org/andromda/timetracker/domain/crud/user-crud";
    }

    /**
     * Initializes the controller. This method can be overridden.
     * @param form
     * @throws Exception
     */
    public void doInit(ManageUserForm form)
        throws Exception
    {

        form.getSearchForm().setUsername(null);
        form.getSearchForm().setPassword(null);
        form.getSearchForm().setFirstName(null);
        form.getSearchForm().setLastName(null);
        form.getSearchForm().setEmail(null);
        form.getSearchForm().setIsActive(null);
        form.getSearchForm().setCreationDate(null);
        form.getSearchForm().setComment(null);
        form.getSearchForm().setRoles(null);

        form.setManageableList(null);

        final Map<String,?> backingLists = ManageableServiceLocator.instance().getUserManageableService().readBackingLists();
        form.setRolesBackingList((Collection)backingLists.get("roles"));

        form.setEditState(false);
    }

    /**
     * The instance load action.
     * @param event
     */
    public void load(ActionEvent event)
    {
        try
        {
            final ManageUserForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doLoad(Long.valueOf(((UIParameter)event.getComponent().findComponent("id")).getValue().toString()),form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
            resetAllEditableComponentsValues();
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }
    }

    /**
     * Loads the selected instance.
     * @param id
     * @param form
     * @throws Exception
     */
    public void doLoad(Long id, ManageUserForm form)
        throws Exception
    {
        final UserValueObject vo=
            ManageableServiceLocator.instance().getUserManageableService().readById(id);

        form.setUsername(vo.getUsername());
        form.setPassword(vo.getPassword());
        form.setFirstName(vo.getFirstName());
        form.setLastName(vo.getLastName());
        form.setEmail(vo.getEmail());
        form.setIsActive(vo.isIsActive());
        form.setCreationDate(vo.getCreationDate());
        form.setComment(vo.getComment());
        form.setId(vo.getId());
        form.setRoles(vo.getRoles());

        form.setEditState(true);
    }

    /**
     * The cancel edit action
     *
     * @return the controller view path.
     */
    public String cancel()
    {
        try
        {
            final ManageUserForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doCancel(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Executes the edit cancel.
     * @param form
     * @throws Exception
     */
    public void doCancel(ManageUserForm form)
        throws Exception
    {
        form.setEditState(false);
    }

    /**
     * The new instance action.
     *
     * @return the controller view path.
     */
    public String startNew()
    {
        try
        {
            final ManageUserForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doStartNew(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Executes the new instance action.
     * @param form
     * @throws Exception
     */
    public void doStartNew(ManageUserForm form)
        throws Exception
    {
        form.setUsername(null);
        form.setPassword(null);
        form.setFirstName(null);
        form.setLastName(null);
        form.setEmail(null);
        form.setIsActive(false);
        form.setCreationDate(null);
        form.setComment(null);
        form.setId(null);

        form.setRoles(null);

        final Map backingLists = ManageableServiceLocator.instance().getUserManageableService().readBackingLists();
        form.setRolesBackingList((Collection)backingLists.get("roles"));

        form.setEditState(true);
    }

    /**
     * The save instance action.
     *
     * @return the controller view path.
     */
    public String save()
    {
        try
        {
            final ManageUserForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doSave(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Saves instance action.
     * @param form
     * @throws Exception
     */
    public void doSave(ManageUserForm form)
        throws Exception
    {
        if(form.getId() == null || form.getId()==0){
            form.setId(
                ManageableServiceLocator.instance().getUserManageableService().create(
                    form.getUsername()
                    , form.getPassword()
                    , form.getFirstName()
                    , form.getLastName()
                    , form.getEmail()
                    , form.isIsActive()
                    , form.getCreationDate()
                    , form.getComment()
                    , null
                    , form.getRoles()
                ).getId()
            );
            this.addInfoMessage(Messages.get("manageable.entity.created", new Object[]{Messages.get("user")}));
        }
        else{
            ManageableServiceLocator.instance().getUserManageableService().update(
                form.getUsername()
                , form.getPassword()
                , form.getFirstName()
                , form.getLastName()
                , form.getEmail()
                , form.isIsActive()
                , form.getCreationDate()
                , form.getComment()
                , form.getId()
                , form.getRoles()
            );
            this.addInfoMessage(Messages.get("manageable.entity.changed", new Object[]{Messages.get("user")}));
        }
        if(form.getManageableList() != null) //only searches again if there was an old search
            doSearch(form); //search again to show the updated item (if it fits the search criteria)

        form.setEditState(false);
    }

    /**
     * The save and new instance action.
     *
     * @return the controller view path.
     */
    public String saveAndNew()
    {
        try
        {
            final ManageUserForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doSave(form);
                this.doStartNew(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * The search action.
     *
     * @return the controller view path.
     */
    public String search()
    {
        try
        {
            final ManageUserForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doSearch(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Executes the search action.
     * @param form
     * @throws Exception
     */
    public void doSearch(ManageUserForm form)
        throws Exception
    {
        @SuppressWarnings("rawtypes")
        final List list;
        //if all search fields are null, call readAll()
        if (
             StringUtils.isBlank(form.getSearchForm().getUsername())
            && StringUtils.isBlank(form.getSearchForm().getPassword())
            && StringUtils.isBlank(form.getSearchForm().getFirstName())
            && StringUtils.isBlank(form.getSearchForm().getLastName())
            && StringUtils.isBlank(form.getSearchForm().getEmail())
            && form.getSearchForm().getIsActive() == null
            && form.getSearchForm().getCreationDate() == null
            && StringUtils.isBlank(form.getSearchForm().getComment())
            && form.getSearchForm().getRoles() == null
            )
            list=ManageableServiceLocator.instance().getUserManageableService().readAll();
        else
            list = ManageableServiceLocator.instance().getUserManageableService().read(
                form.getSearchForm().getUsername()
                , form.getSearchForm().getPassword()
                , form.getSearchForm().getFirstName()
                , form.getSearchForm().getLastName()
                , form.getSearchForm().getEmail()
                , form.getSearchForm().getIsActive()
                , form.getSearchForm().getCreationDate()
                , form.getSearchForm().getComment()
                , null
                , form.getSearchForm().getRoles()
            );

        form.setManageableList(list);
        if (list.size() >= 250)
            saveMaxResultsWarning();

        final Map<String,?> backingLists = ManageableServiceLocator.instance().getUserManageableService().readBackingLists();
        form.setRolesBackingList((Collection)backingLists.get("roles"));

        form.setEditState(false);
    }

    /**
     * The delete event.
     * @param event
     */
    public void delete(ActionEvent event)
    {
        try
        {
            final ManageUserForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doDelete(Long.valueOf(((UIParameter)event.getComponent().findComponent("id")).getValue().toString()),form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
            resetAllEditableComponentsValues();
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }
    }

    /**
     * Deletes the selected instance.
     * @param id
     * @param form
     * @throws Exception
     */
    public void doDelete(Long id, ManageUserForm form)
        throws Exception
    {
        ManageableServiceLocator.instance().getUserManageableService().delete(new Long[]{id});
        this.addInfoMessage(Messages.get("manageable.entity.deleted", new Object[]{Messages.get("user")}));

        doSearch(form);
    }

    /**
     * Shows a message warning the user can exists more records available.
     */
    private void saveMaxResultsWarning()
    {
        addWarningMessage(Messages.get("maximum.results.fetched.warning", new Object[]{String.valueOf("250")}));
    }

    /**
     * Loads an instance of User.
     *
     * @return UserValueObject from the loaded entity.
     */
    static public UserValueObject load(Long id)
    {
        if(id == null || id == 0)
        {
            return null;
        }
        try
        {
            return ManageableServiceLocator.instance().getUserManageableService().readById(id);
        }
        catch(Exception e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * Helper method to fill the select component list.
     *
     * @return a collection with the filtered list.
     */
    public Collection<SelectItem> getAsSelectItems()
    {
        final Collection<UserValueObject> vos;
        try {
            vos = ManageableServiceLocator.instance().getUserManageableService().readAll();
        } catch (final Throwable throwable) {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
            return null;
        }
        final Collection<SelectItem> result=new ArrayList<SelectItem>(vos.size());
        for(UserValueObject vo: vos){
            result.add(new SelectItem(vo.getId(),ObjectUtils.toString(vo.getUsername())));
        }
        return result;
    }

    /** manageTaskForm */
    public static final String FORM_BEAN_NAME="manageUserForm";

    /**
     * Resolves "manageUserForm".
     *
     * @return the manageable form.
     */
    public ManageUserForm getForm()
    {
        final Map<String,Object> forms=getForms();
        ManageUserForm form=(ManageUserForm)forms.get(FORM_BEAN_NAME);
        if(form == null){
            form = new ManageUserForm();
            forms.put(FORM_BEAN_NAME,form);
        }
        return form;
    }

    // crud-controller merge-point
}