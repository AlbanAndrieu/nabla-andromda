// license-header java merge-point
// Generated by andromda-jsf cartridge (controllers\crud\Controller.java.vsl) DO NOT EDIT!
package org.andromda.timetracker.domain.crud;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import javax.faces.component.UIParameter;
import javax.faces.event.ActionEvent;
import javax.faces.model.SelectItem;
import org.andromda.presentation.gui.ControllerBase;
import org.andromda.presentation.gui.Messages;
import org.andromda.presentation.gui.PatternMatchingExceptionHandler;
import org.andromda.timetracker.ManageableServiceLocator;
import org.apache.commons.lang.ObjectUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Java Server Faces Controller of the Task CRUD management.
 */
public abstract class TaskController
    extends ControllerBase
{
    private static final Log logger = LogFactory.getLog(TaskController.class);

    /**
     * Initializes the controller, calling the doInit method
     *
     * @return the controller view path.
     */
    public String init()
    {
        this.resetUseCaseFormsAndPageVariables();

        try
        {
            final ManageTaskForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doInit(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }
        return "/org/andromda/timetracker/domain/crud/task-crud";
    }

    /**
     * Initializes the controller. This method can be overridden.
     * @param form
     * @throws Exception
     */
    public void doInit(ManageTaskForm form)
        throws Exception
    {

        form.getSearchForm().setName(null);

        form.setManageableList(null);


        form.setEditState(false);
    }

    /**
     * The instance load action.
     * @param event
     */
    public void load(ActionEvent event)
    {
        try
        {
            final ManageTaskForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doLoad(Long.valueOf(((UIParameter)event.getComponent().findComponent("id")).getValue().toString()),form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
            resetAllEditableComponentsValues();
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }
    }

    /**
     * Loads the selected instance.
     * @param id
     * @param form
     * @throws Exception
     */
    public void doLoad(Long id, ManageTaskForm form)
        throws Exception
    {
        final TaskValueObject vo=
            ManageableServiceLocator.instance().getTaskManageableService().readById(id);

        form.setName(vo.getName());
        form.setId(vo.getId());

        form.setEditState(true);
    }

    /**
     * The cancel edit action
     *
     * @return the controller view path.
     */
    public String cancel()
    {
        try
        {
            final ManageTaskForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doCancel(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Executes the edit cancel.
     * @param form
     * @throws Exception
     */
    public void doCancel(ManageTaskForm form)
        throws Exception
    {
        form.setEditState(false);
    }

    /**
     * The new instance action.
     *
     * @return the controller view path.
     */
    public String startNew()
    {
        try
        {
            final ManageTaskForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doStartNew(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Executes the new instance action.
     * @param form
     * @throws Exception
     */
    public void doStartNew(ManageTaskForm form)
        throws Exception
    {
        form.setName(null);
        form.setId(null);


        form.setEditState(true);
    }

    /**
     * The save instance action.
     *
     * @return the controller view path.
     */
    public String save()
    {
        try
        {
            final ManageTaskForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doSave(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Saves instance action.
     * @param form
     * @throws Exception
     */
    public void doSave(ManageTaskForm form)
        throws Exception
    {
        if(form.getId() == null || form.getId()==0){
            form.setId(
                ManageableServiceLocator.instance().getTaskManageableService().create(
                    form.getName()
                    , null
                ).getId()
            );
            this.addInfoMessage(Messages.get("manageable.entity.created", new Object[]{Messages.get("task")}));
        }
        else{
            ManageableServiceLocator.instance().getTaskManageableService().update(
                form.getName()
                , form.getId()
            );
            this.addInfoMessage(Messages.get("manageable.entity.changed", new Object[]{Messages.get("task")}));
        }
        if(form.getManageableList() != null) //only searches again if there was an old search
            doSearch(form); //search again to show the updated item (if it fits the search criteria)

        form.setEditState(false);
    }

    /**
     * The save and new instance action.
     *
     * @return the controller view path.
     */
    public String saveAndNew()
    {
        try
        {
            final ManageTaskForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doSave(form);
                this.doStartNew(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * The search action.
     *
     * @return the controller view path.
     */
    public String search()
    {
        try
        {
            final ManageTaskForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doSearch(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Executes the search action.
     * @param form
     * @throws Exception
     */
    public void doSearch(ManageTaskForm form)
        throws Exception
    {
        @SuppressWarnings("rawtypes")
        final List list;
        //if all search fields are null, call readAll()
        if (
             StringUtils.isBlank(form.getSearchForm().getName())
            )
            list=ManageableServiceLocator.instance().getTaskManageableService().readAll();
        else
            list = ManageableServiceLocator.instance().getTaskManageableService().read(
                form.getSearchForm().getName()
                , null
            );

        form.setManageableList(list);
        if (list.size() >= 250)
            saveMaxResultsWarning();


        form.setEditState(false);
    }

    /**
     * The delete event.
     * @param event
     */
    public void delete(ActionEvent event)
    {
        try
        {
            final ManageTaskForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doDelete(Long.valueOf(((UIParameter)event.getComponent().findComponent("id")).getValue().toString()),form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
            resetAllEditableComponentsValues();
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }
    }

    /**
     * Deletes the selected instance.
     * @param id
     * @param form
     * @throws Exception
     */
    public void doDelete(Long id, ManageTaskForm form)
        throws Exception
    {
        ManageableServiceLocator.instance().getTaskManageableService().delete(new Long[]{id});
        this.addInfoMessage(Messages.get("manageable.entity.deleted", new Object[]{Messages.get("task")}));

        doSearch(form);
    }

    /**
     * Shows a message warning the user can exists more records available.
     */
    private void saveMaxResultsWarning()
    {
        addWarningMessage(Messages.get("maximum.results.fetched.warning", new Object[]{String.valueOf("250")}));
    }

    /**
     * Loads an instance of Task.
     *
     * @return TaskValueObject from the loaded entity.
     */
    static public TaskValueObject load(Long id)
    {
        if(id == null || id == 0)
        {
            return null;
        }
        try
        {
            return ManageableServiceLocator.instance().getTaskManageableService().readById(id);
        }
        catch(Exception e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * Helper method to fill the select component list.
     *
     * @return a collection with the filtered list.
     */
    public Collection<SelectItem> getAsSelectItems()
    {
        final Collection<TaskValueObject> vos;
        try {
            vos = ManageableServiceLocator.instance().getTaskManageableService().readAll();
        } catch (final Throwable throwable) {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
            return null;
        }
        final Collection<SelectItem> result=new ArrayList<SelectItem>(vos.size());
        for(TaskValueObject vo: vos){
            result.add(new SelectItem(vo.getId(),ObjectUtils.toString(vo.getName())));
        }
        return result;
    }

    /** manageTaskForm */
    public static final String FORM_BEAN_NAME="manageTaskForm";

    /**
     * Resolves "manageTaskForm".
     *
     * @return the manageable form.
     */
    public ManageTaskForm getForm()
    {
        final Map<String,Object> forms=getForms();
        ManageTaskForm form=(ManageTaskForm)forms.get(FORM_BEAN_NAME);
        if(form == null){
            form = new ManageTaskForm();
            forms.put(FORM_BEAN_NAME,form);
        }
        return form;
    }

    // crud-controller merge-point
}