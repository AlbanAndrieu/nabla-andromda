// license-header java merge-point
// Generated by andromda-jsf cartridge (forms\FormImpl.java.vsl)
package org.andromda.timetracker.web.timecardsearch;

import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.faces.application.FacesMessage;
import javax.faces.event.ActionEvent;
import javax.faces.event.FacesEvent;
import javax.faces.event.ValueChangeEvent;
import javax.faces.model.SelectItem;
import javax.validation.constraints.NotNull;
import org.andromda.timetracker.vo.TimecardSummaryVO;
import org.apache.commons.beanutils.PropertyUtils;

/**
 * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.search
 */
public class SearchTimecardsSearchFormImpl
    implements Serializable, PopulateSearchScreenForm
{
    /**
     * Default constructor
     */
    public SearchTimecardsSearchFormImpl()
    {
        final DateFormat timecardSummariesStartDateDateFormatter = new SimpleDateFormat("MM/dd/yyyy");
        timecardSummariesStartDateDateFormatter.setLenient(true);
        this.dateTimeFormatters.put("timecardSummaries.startDate", timecardSummariesStartDateDateFormatter);
        final DateFormat startDateMinimumDateFormatter = new SimpleDateFormat("MM/dd/yyyy");
        startDateMinimumDateFormatter.setLenient(true);
        this.dateTimeFormatters.put("startDateMinimum", startDateMinimumDateFormatter);
        final DateFormat startDateMaximumDateFormatter = new SimpleDateFormat("MM/dd/yyyy");
        startDateMaximumDateFormatter.setLenient(true);
        this.dateTimeFormatters.put("startDateMaximum", startDateMaximumDateFormatter);
        // - setup the default Date.toString() formatter
        final DateFormat dateFormatter = new SimpleDateFormat("EEE MMM dd hh:mm:ss zzz yyyy");
        dateFormatter.setLenient(true);
        this.dateTimeFormatters.put(null, dateFormatter);
    }

    private transient FacesEvent event;

    /**
     * @param eventIn
     */
    @Override
    public void setEvent(FacesEvent eventIn)
    {
        this.event = eventIn;
    }

    /**
     * @return ValueChangeEvent
     */
    @Override
    public ValueChangeEvent getValueChangeEvent()
    {
        return this.event instanceof ValueChangeEvent
            ? (ValueChangeEvent)this.event : null;
    }

    /**
     * @return ActionEvent
     */
    @Override
    public ActionEvent getActionEvent()
    {
        return this.event instanceof ActionEvent
            ? (ActionEvent)this.event : null;
    }

    // Action search-timecards-search formFields

    @NotNull
    private TimecardSummaryVO[] timecardSummaries;

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.timecardSummaries
     * @return timecardSummaries TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.timecardSummaries
     */
    public TimecardSummaryVO[] getTimecardSummaries()
    {
        return this.timecardSummaries;
    }

    /**
     * Keeps track of whether or not the value of timecardSummaries has
     * be populated at least once.
     */
    private boolean timecardSummariesSet = false;

    /**
     * Resets the value of the timecardSummariesSet to false
     */
    public void resetTimecardSummariesSet()
    {
        this.timecardSummariesSet = false;
    }

    /**
     * Indicates whether or not the value for timecardSummaries has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTimecardSummariesSet()
    {
        return this.timecardSummariesSet;
    }

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.timecardSummaries
     * @param timecardSummariesIn TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.timecardSummaries
     */
    public void setTimecardSummaries(TimecardSummaryVO[] timecardSummariesIn)
    {
        this.timecardSummaries = timecardSummariesIn;
        this.timecardSummariesSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] timecardSummariesValueList;

    /**
     * Stores the labels
     */
    private Object[] timecardSummariesLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTimecardSummariesBackingList()
    {
        Object[] values = this.timecardSummariesValueList;
        Object[] labels = this.timecardSummariesLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return timecardSummariesValueList
     */
    public Object[] getTimecardSummariesValueList()
    {
        return this.timecardSummariesValueList;
    }

    /**
     * @param timecardSummariesValueListIn
     */
    public void setTimecardSummariesValueList(Object[] timecardSummariesValueListIn)
    {
        this.timecardSummariesValueList = timecardSummariesValueListIn;
    }

    /**
     * @return timecardSummariesLabelList Object[]
     */
    public Object[] getTimecardSummariesLabelList()
    {
        return this.timecardSummariesLabelList;
    }

    /**
     * @param timecardSummariesLabelListIn
     */
    public void setTimecardSummariesLabelList(Object[] timecardSummariesLabelListIn)
    {
        this.timecardSummariesLabelList = timecardSummariesLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTimecardSummariesBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.timecardSummariesValueList = null;
        this.timecardSummariesLabelList = null;
        if (items != null)
        {
            this.timecardSummariesValueList = new Object[items.size()];
            this.timecardSummariesLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.timecardSummariesValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.timecardSummariesLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.timecardSummariesLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private TimecardSummaryVO[] timecardSummariesBackingValue;

    /**
     * @param timecardSummariesBackingValueIn
     */
    public void setTimecardSummariesBackingValue(TimecardSummaryVO[] timecardSummariesBackingValueIn)
    {
        this.timecardSummariesBackingValue = timecardSummariesBackingValueIn;
    }

    /**
     * @return timecardSummariesBackingValue
     */
    public TimecardSummaryVO[] getTimecardSummariesBackingValue()
    {
        return this.timecardSummariesBackingValue;
    }

    // timecardSummaries attributes

    /**
     * Stores the values.
     */
    private Object[] timecardSummariesIdValueList;

    /**
     * Stores the labels
     */
    private Object[] timecardSummariesIdLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTimecardSummariesIdBackingList()
    {
        Object[] values = this.timecardSummariesIdValueList;
        Object[] labels = this.timecardSummariesIdLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return timecardSummariesIdValueList
     */
    public Object[] getTimecardSummariesIdValueList()
    {
        return this.timecardSummariesIdValueList;
    }

    /**
     * @param timecardSummariesIdValueListIn
     */
    public void setTimecardSummariesIdValueList(Object[] timecardSummariesIdValueListIn)
    {
        this.timecardSummariesIdValueList = timecardSummariesIdValueListIn;
    }

    /**
     * @return timecardSummariesIdLabelList Object[]
     */
    public Object[] getTimecardSummariesIdLabelList()
    {
        return this.timecardSummariesIdLabelList;
    }

    /**
     * @param timecardSummariesIdLabelListIn
     */
    public void setTimecardSummariesIdLabelList(Object[] timecardSummariesIdLabelListIn)
    {
        this.timecardSummariesIdLabelList = timecardSummariesIdLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTimecardSummariesIdBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.timecardSummariesIdValueList = null;
        this.timecardSummariesIdLabelList = null;
        if (items != null)
        {
            this.timecardSummariesIdValueList = new Object[items.size()];
            this.timecardSummariesIdLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.timecardSummariesIdValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.timecardSummariesIdLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.timecardSummariesIdLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }

    /**
     * Stores the values.
     */
    private Object[] timecardSummariesStatusValueList;

    /**
     * Stores the labels
     */
    private Object[] timecardSummariesStatusLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTimecardSummariesStatusBackingList()
    {
        Object[] values = this.timecardSummariesStatusValueList;
        Object[] labels = this.timecardSummariesStatusLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return timecardSummariesStatusValueList
     */
    public Object[] getTimecardSummariesStatusValueList()
    {
        return this.timecardSummariesStatusValueList;
    }

    /**
     * @param timecardSummariesStatusValueListIn
     */
    public void setTimecardSummariesStatusValueList(Object[] timecardSummariesStatusValueListIn)
    {
        this.timecardSummariesStatusValueList = timecardSummariesStatusValueListIn;
    }

    /**
     * @return timecardSummariesStatusLabelList Object[]
     */
    public Object[] getTimecardSummariesStatusLabelList()
    {
        return this.timecardSummariesStatusLabelList;
    }

    /**
     * @param timecardSummariesStatusLabelListIn
     */
    public void setTimecardSummariesStatusLabelList(Object[] timecardSummariesStatusLabelListIn)
    {
        this.timecardSummariesStatusLabelList = timecardSummariesStatusLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTimecardSummariesStatusBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.timecardSummariesStatusValueList = null;
        this.timecardSummariesStatusLabelList = null;
        if (items != null)
        {
            this.timecardSummariesStatusValueList = new Object[items.size()];
            this.timecardSummariesStatusLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.timecardSummariesStatusValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.timecardSummariesStatusLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.timecardSummariesStatusLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }

    /**
     * Stores the values.
     */
    private Object[] timecardSummariesStartDateValueList;

    /**
     * Stores the labels
     */
    private Object[] timecardSummariesStartDateLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTimecardSummariesStartDateBackingList()
    {
        Object[] values = this.timecardSummariesStartDateValueList;
        Object[] labels = this.timecardSummariesStartDateLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return timecardSummariesStartDateValueList
     */
    public Object[] getTimecardSummariesStartDateValueList()
    {
        return this.timecardSummariesStartDateValueList;
    }

    /**
     * @param timecardSummariesStartDateValueListIn
     */
    public void setTimecardSummariesStartDateValueList(Object[] timecardSummariesStartDateValueListIn)
    {
        this.timecardSummariesStartDateValueList = timecardSummariesStartDateValueListIn;
    }

    /**
     * @return timecardSummariesStartDateLabelList Object[]
     */
    public Object[] getTimecardSummariesStartDateLabelList()
    {
        return this.timecardSummariesStartDateLabelList;
    }

    /**
     * @param timecardSummariesStartDateLabelListIn
     */
    public void setTimecardSummariesStartDateLabelList(Object[] timecardSummariesStartDateLabelListIn)
    {
        this.timecardSummariesStartDateLabelList = timecardSummariesStartDateLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTimecardSummariesStartDateBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.timecardSummariesStartDateValueList = null;
        this.timecardSummariesStartDateLabelList = null;
        if (items != null)
        {
            this.timecardSummariesStartDateValueList = new Object[items.size()];
            this.timecardSummariesStartDateLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.timecardSummariesStartDateValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.timecardSummariesStartDateLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.timecardSummariesStartDateLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }

    /**
     * Stores the values.
     */
    private Object[] timecardSummariesCommentsValueList;

    /**
     * Stores the labels
     */
    private Object[] timecardSummariesCommentsLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTimecardSummariesCommentsBackingList()
    {
        Object[] values = this.timecardSummariesCommentsValueList;
        Object[] labels = this.timecardSummariesCommentsLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return timecardSummariesCommentsValueList
     */
    public Object[] getTimecardSummariesCommentsValueList()
    {
        return this.timecardSummariesCommentsValueList;
    }

    /**
     * @param timecardSummariesCommentsValueListIn
     */
    public void setTimecardSummariesCommentsValueList(Object[] timecardSummariesCommentsValueListIn)
    {
        this.timecardSummariesCommentsValueList = timecardSummariesCommentsValueListIn;
    }

    /**
     * @return timecardSummariesCommentsLabelList Object[]
     */
    public Object[] getTimecardSummariesCommentsLabelList()
    {
        return this.timecardSummariesCommentsLabelList;
    }

    /**
     * @param timecardSummariesCommentsLabelListIn
     */
    public void setTimecardSummariesCommentsLabelList(Object[] timecardSummariesCommentsLabelListIn)
    {
        this.timecardSummariesCommentsLabelList = timecardSummariesCommentsLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTimecardSummariesCommentsBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.timecardSummariesCommentsValueList = null;
        this.timecardSummariesCommentsLabelList = null;
        if (items != null)
        {
            this.timecardSummariesCommentsValueList = new Object[items.size()];
            this.timecardSummariesCommentsLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.timecardSummariesCommentsValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.timecardSummariesCommentsLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.timecardSummariesCommentsLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }

    /**
     * Stores the values.
     */
    private Object[] timecardSummariesSubmitterNameValueList;

    /**
     * Stores the labels
     */
    private Object[] timecardSummariesSubmitterNameLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTimecardSummariesSubmitterNameBackingList()
    {
        Object[] values = this.timecardSummariesSubmitterNameValueList;
        Object[] labels = this.timecardSummariesSubmitterNameLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return timecardSummariesSubmitterNameValueList
     */
    public Object[] getTimecardSummariesSubmitterNameValueList()
    {
        return this.timecardSummariesSubmitterNameValueList;
    }

    /**
     * @param timecardSummariesSubmitterNameValueListIn
     */
    public void setTimecardSummariesSubmitterNameValueList(Object[] timecardSummariesSubmitterNameValueListIn)
    {
        this.timecardSummariesSubmitterNameValueList = timecardSummariesSubmitterNameValueListIn;
    }

    /**
     * @return timecardSummariesSubmitterNameLabelList Object[]
     */
    public Object[] getTimecardSummariesSubmitterNameLabelList()
    {
        return this.timecardSummariesSubmitterNameLabelList;
    }

    /**
     * @param timecardSummariesSubmitterNameLabelListIn
     */
    public void setTimecardSummariesSubmitterNameLabelList(Object[] timecardSummariesSubmitterNameLabelListIn)
    {
        this.timecardSummariesSubmitterNameLabelList = timecardSummariesSubmitterNameLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTimecardSummariesSubmitterNameBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.timecardSummariesSubmitterNameValueList = null;
        this.timecardSummariesSubmitterNameLabelList = null;
        if (items != null)
        {
            this.timecardSummariesSubmitterNameValueList = new Object[items.size()];
            this.timecardSummariesSubmitterNameLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.timecardSummariesSubmitterNameValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.timecardSummariesSubmitterNameLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.timecardSummariesSubmitterNameLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }

    /**
     * Stores the values.
     */
    private Object[] timecardSummariesApproverNameValueList;

    /**
     * Stores the labels
     */
    private Object[] timecardSummariesApproverNameLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTimecardSummariesApproverNameBackingList()
    {
        Object[] values = this.timecardSummariesApproverNameValueList;
        Object[] labels = this.timecardSummariesApproverNameLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return timecardSummariesApproverNameValueList
     */
    public Object[] getTimecardSummariesApproverNameValueList()
    {
        return this.timecardSummariesApproverNameValueList;
    }

    /**
     * @param timecardSummariesApproverNameValueListIn
     */
    public void setTimecardSummariesApproverNameValueList(Object[] timecardSummariesApproverNameValueListIn)
    {
        this.timecardSummariesApproverNameValueList = timecardSummariesApproverNameValueListIn;
    }

    /**
     * @return timecardSummariesApproverNameLabelList Object[]
     */
    public Object[] getTimecardSummariesApproverNameLabelList()
    {
        return this.timecardSummariesApproverNameLabelList;
    }

    /**
     * @param timecardSummariesApproverNameLabelListIn
     */
    public void setTimecardSummariesApproverNameLabelList(Object[] timecardSummariesApproverNameLabelListIn)
    {
        this.timecardSummariesApproverNameLabelList = timecardSummariesApproverNameLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTimecardSummariesApproverNameBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.timecardSummariesApproverNameValueList = null;
        this.timecardSummariesApproverNameLabelList = null;
        if (items != null)
        {
            this.timecardSummariesApproverNameValueList = new Object[items.size()];
            this.timecardSummariesApproverNameLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.timecardSummariesApproverNameValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.timecardSummariesApproverNameLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.timecardSummariesApproverNameLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Long submitter;

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.submitter
     * @return submitter TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.submitter
     */
    public Long getSubmitter()
    {
        return this.submitter;
    }

    /**
     * Keeps track of whether or not the value of submitter has
     * be populated at least once.
     */
    private boolean submitterSet = false;

    /**
     * Resets the value of the submitterSet to false
     */
    public void resetSubmitterSet()
    {
        this.submitterSet = false;
    }

    /**
     * Indicates whether or not the value for submitter has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isSubmitterSet()
    {
        return this.submitterSet;
    }

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.submitter
     * @param submitterIn TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.submitter
     */
    public void setSubmitter(Long submitterIn)
    {
        this.submitter = submitterIn;
        this.submitterSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] submitterValueList;

    /**
     * Stores the labels
     */
    private Object[] submitterLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getSubmitterBackingList()
    {
        Object[] values = this.submitterValueList;
        Object[] labels = this.submitterLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return submitterValueList
     */
    public Object[] getSubmitterValueList()
    {
        return this.submitterValueList;
    }

    /**
     * @param submitterValueListIn
     */
    public void setSubmitterValueList(Object[] submitterValueListIn)
    {
        this.submitterValueList = submitterValueListIn;
    }

    /**
     * @return submitterLabelList Object[]
     */
    public Object[] getSubmitterLabelList()
    {
        return this.submitterLabelList;
    }

    /**
     * @param submitterLabelListIn
     */
    public void setSubmitterLabelList(Object[] submitterLabelListIn)
    {
        this.submitterLabelList = submitterLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setSubmitterBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.submitterValueList = null;
        this.submitterLabelList = null;
        if (items != null)
        {
            this.submitterValueList = new Object[items.size()];
            this.submitterLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.submitterValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.submitterLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.submitterLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Long approver;

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.approver
     * @return approver TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.approver
     */
    public Long getApprover()
    {
        return this.approver;
    }

    /**
     * Keeps track of whether or not the value of approver has
     * be populated at least once.
     */
    private boolean approverSet = false;

    /**
     * Resets the value of the approverSet to false
     */
    public void resetApproverSet()
    {
        this.approverSet = false;
    }

    /**
     * Indicates whether or not the value for approver has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isApproverSet()
    {
        return this.approverSet;
    }

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.approver
     * @param approverIn TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.approver
     */
    public void setApprover(Long approverIn)
    {
        this.approver = approverIn;
        this.approverSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] approverValueList;

    /**
     * Stores the labels
     */
    private Object[] approverLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getApproverBackingList()
    {
        Object[] values = this.approverValueList;
        Object[] labels = this.approverLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return approverValueList
     */
    public Object[] getApproverValueList()
    {
        return this.approverValueList;
    }

    /**
     * @param approverValueListIn
     */
    public void setApproverValueList(Object[] approverValueListIn)
    {
        this.approverValueList = approverValueListIn;
    }

    /**
     * @return approverLabelList Object[]
     */
    public Object[] getApproverLabelList()
    {
        return this.approverLabelList;
    }

    /**
     * @param approverLabelListIn
     */
    public void setApproverLabelList(Object[] approverLabelListIn)
    {
        this.approverLabelList = approverLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setApproverBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.approverValueList = null;
        this.approverLabelList = null;
        if (items != null)
        {
            this.approverValueList = new Object[items.size()];
            this.approverLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.approverValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.approverLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.approverLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String status;

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.status
     * @return status TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.status
     */
    public String getStatus()
    {
        return this.status;
    }

    /**
     * Keeps track of whether or not the value of status has
     * be populated at least once.
     */
    private boolean statusSet = false;

    /**
     * Resets the value of the statusSet to false
     */
    public void resetStatusSet()
    {
        this.statusSet = false;
    }

    /**
     * Indicates whether or not the value for status has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isStatusSet()
    {
        return this.statusSet;
    }

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.status
     * @param statusIn TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.status
     */
    public void setStatus(String statusIn)
    {
        this.status = statusIn;
        this.statusSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] statusValueList;

    /**
     * Stores the labels
     */
    private Object[] statusLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getStatusBackingList()
    {
        Object[] values = this.statusValueList;
        Object[] labels = this.statusLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return statusValueList
     */
    public Object[] getStatusValueList()
    {
        return this.statusValueList;
    }

    /**
     * @param statusValueListIn
     */
    public void setStatusValueList(Object[] statusValueListIn)
    {
        this.statusValueList = statusValueListIn;
    }

    /**
     * @return statusLabelList Object[]
     */
    public Object[] getStatusLabelList()
    {
        return this.statusLabelList;
    }

    /**
     * @param statusLabelListIn
     */
    public void setStatusLabelList(Object[] statusLabelListIn)
    {
        this.statusLabelList = statusLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setStatusBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.statusValueList = null;
        this.statusLabelList = null;
        if (items != null)
        {
            this.statusValueList = new Object[items.size()];
            this.statusLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.statusValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.statusLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.statusLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Date startDateMinimum;

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.startDateMinimum
     * @return startDateMinimum TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.startDateMinimum
     */
    public Date getStartDateMinimum()
    {
        return this.startDateMinimum;
    }

    /**
     * Keeps track of whether or not the value of startDateMinimum has
     * be populated at least once.
     */
    private boolean startDateMinimumSet = false;

    /**
     * Resets the value of the startDateMinimumSet to false
     */
    public void resetStartDateMinimumSet()
    {
        this.startDateMinimumSet = false;
    }

    /**
     * Indicates whether or not the value for startDateMinimum has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isStartDateMinimumSet()
    {
        return this.startDateMinimumSet;
    }

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.startDateMinimum
     * @param startDateMinimumIn TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.startDateMinimum
     */
    public void setStartDateMinimum(Date startDateMinimumIn)
    {
        this.startDateMinimum = startDateMinimumIn;
        this.startDateMinimumSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] startDateMinimumValueList;

    /**
     * Stores the labels
     */
    private Object[] startDateMinimumLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getStartDateMinimumBackingList()
    {
        Object[] values = this.startDateMinimumValueList;
        Object[] labels = this.startDateMinimumLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return startDateMinimumValueList
     */
    public Object[] getStartDateMinimumValueList()
    {
        return this.startDateMinimumValueList;
    }

    /**
     * @param startDateMinimumValueListIn
     */
    public void setStartDateMinimumValueList(Object[] startDateMinimumValueListIn)
    {
        this.startDateMinimumValueList = startDateMinimumValueListIn;
    }

    /**
     * @return startDateMinimumLabelList Object[]
     */
    public Object[] getStartDateMinimumLabelList()
    {
        return this.startDateMinimumLabelList;
    }

    /**
     * @param startDateMinimumLabelListIn
     */
    public void setStartDateMinimumLabelList(Object[] startDateMinimumLabelListIn)
    {
        this.startDateMinimumLabelList = startDateMinimumLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setStartDateMinimumBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.startDateMinimumValueList = null;
        this.startDateMinimumLabelList = null;
        if (items != null)
        {
            this.startDateMinimumValueList = new Object[items.size()];
            this.startDateMinimumLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.startDateMinimumValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.startDateMinimumLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.startDateMinimumLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Date startDateMaximum;

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.startDateMaximum
     * @return startDateMaximum TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.startDateMaximum
     */
    public Date getStartDateMaximum()
    {
        return this.startDateMaximum;
    }

    /**
     * Keeps track of whether or not the value of startDateMaximum has
     * be populated at least once.
     */
    private boolean startDateMaximumSet = false;

    /**
     * Resets the value of the startDateMaximumSet to false
     */
    public void resetStartDateMaximumSet()
    {
        this.startDateMaximumSet = false;
    }

    /**
     * Indicates whether or not the value for startDateMaximum has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isStartDateMaximumSet()
    {
        return this.startDateMaximumSet;
    }

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.startDateMaximum
     * @param startDateMaximumIn TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.startDateMaximum
     */
    public void setStartDateMaximum(Date startDateMaximumIn)
    {
        this.startDateMaximum = startDateMaximumIn;
        this.startDateMaximumSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] startDateMaximumValueList;

    /**
     * Stores the labels
     */
    private Object[] startDateMaximumLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getStartDateMaximumBackingList()
    {
        Object[] values = this.startDateMaximumValueList;
        Object[] labels = this.startDateMaximumLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return startDateMaximumValueList
     */
    public Object[] getStartDateMaximumValueList()
    {
        return this.startDateMaximumValueList;
    }

    /**
     * @param startDateMaximumValueListIn
     */
    public void setStartDateMaximumValueList(Object[] startDateMaximumValueListIn)
    {
        this.startDateMaximumValueList = startDateMaximumValueListIn;
    }

    /**
     * @return startDateMaximumLabelList Object[]
     */
    public Object[] getStartDateMaximumLabelList()
    {
        return this.startDateMaximumLabelList;
    }

    /**
     * @param startDateMaximumLabelListIn
     */
    public void setStartDateMaximumLabelList(Object[] startDateMaximumLabelListIn)
    {
        this.startDateMaximumLabelList = startDateMaximumLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setStartDateMaximumBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.startDateMaximumValueList = null;
        this.startDateMaximumLabelList = null;
        if (items != null)
        {
            this.startDateMaximumValueList = new Object[items.size()];
            this.startDateMaximumLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.startDateMaximumValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.startDateMaximumLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.startDateMaximumLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Long id;

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.id
     * @return id TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.id
     */
    public Long getId()
    {
        return this.id;
    }

    /**
     * Keeps track of whether or not the value of id has
     * be populated at least once.
     */
    private boolean idSet = false;

    /**
     * Resets the value of the idSet to false
     */
    public void resetIdSet()
    {
        this.idSet = false;
    }

    /**
     * Indicates whether or not the value for id has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isIdSet()
    {
        return this.idSet;
    }

    /**
     * TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.id
     * @param idIn TODO: Model Documentation for org.andromda.timetracker.web.timecardsearch.id
     */
    public void setId(Long idIn)
    {
        this.id = idIn;
        this.idSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] idValueList;

    /**
     * Stores the labels
     */
    private Object[] idLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getIdBackingList()
    {
        Object[] values = this.idValueList;
        Object[] labels = this.idLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return idValueList
     */
    public Object[] getIdValueList()
    {
        return this.idValueList;
    }

    /**
     * @param idValueListIn
     */
    public void setIdValueList(Object[] idValueListIn)
    {
        this.idValueList = idValueListIn;
    }

    /**
     * @return idLabelList Object[]
     */
    public Object[] getIdLabelList()
    {
        return this.idLabelList;
    }

    /**
     * @param idLabelListIn
     */
    public void setIdLabelList(Object[] idLabelListIn)
    {
        this.idLabelList = idLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setIdBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.idValueList = null;
        this.idLabelList = null;
        if (items != null)
        {
            this.idValueList = new Object[items.size()];
            this.idLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.idValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.idLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.idLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    /**
     * Resets all the "isSet" flags.
     */
     public void resetIsSetFlags()
     {
         this.resetTimecardSummariesSet();
         this.resetSubmitterSet();
         this.resetApproverSet();
         this.resetStatusSet();
         this.resetStartDateMinimumSet();
         this.resetStartDateMaximumSet();
         this.resetIdSet();
     }

    /**
     * Stores any date or time formatters for this form.
     */
    private final Map<String, DateFormat> dateTimeFormatters =
        new HashMap<String, DateFormat>();

    /**
     * Gets any date and time formatters (keyed by property name)
     * for this form.
     *
     * @return the Map containing any date and time formatters.
     */
    public Map<String, DateFormat> getDateTimeFormatters()
    {
        return this.dateTimeFormatters;
    }

    /**
     * The current collection of messages stored within this form.
     */
    private transient Map<String, FacesMessage> jsfMessages =
        new LinkedHashMap<String, FacesMessage>();


    /**
     * Adds a {@link FacesMessage} message to the current messages
     * stored within this form.
     *
     * @param jsfMessage the faces message to add.
     */
    public void addJsfMessages(FacesMessage jsfMessage)
    {
        if (this.jsfMessages != null)
        {
            this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
        }
    }

    /**
     * Gets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @return the current Faces messages.
     */
    public Collection<FacesMessage> getJsfMessages()
    {
        if (this.jsfMessages == null)
        {
            this.jsfMessages = new LinkedHashMap<String, FacesMessage>();
        }
        return this.jsfMessages.values();
    }

    /**
     * Sets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @param messages a collection of the current Faces messages.
     */
    public void setJsfMessages(final Collection<FacesMessage> messages)
    {
        if (messages != null)
        {
            for (final FacesMessage jsfMessage: messages)
            {
                this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
            }
        }
    }

    /**
     * Clear the current {@link FacesMessage} message
     * instances stored within this form.
     */
    public void clearJsfMessages()
    {
        this.jsfMessages.clear();
    }

    /**
     * The faces message title (used on a view).
     */
    private String jsfMessagesTitle;

    /**
     * The optional faces message title to set (used on a view).  If not set, the default title
     * will be used.
     *
     * @param jsfMessagesTitleIn the title to use for the messages on the view.
     */
    public void setJsfMessagesTitle(final String jsfMessagesTitleIn)
    {
        this.jsfMessagesTitle = jsfMessagesTitleIn;
    }

    /**
     * Gets the faces messages title to use.
     *
     * @return the faces messages title.
     */
    public String getJsfMessagesTitle()
    {
        return this.jsfMessagesTitle;
    }

    /**
     * Gets the maximum severity of the messages stored in this form.
     *
     * @return the maximum severity or null if no messages are present and/or severity isn't set.
     */
    public FacesMessage.Severity getMaximumMessageSeverity()
    {
        FacesMessage.Severity maxSeverity = null;
        for (final FacesMessage message : this.getJsfMessages())
        {
            final FacesMessage.Severity severity = message.getSeverity();
            if (maxSeverity == null || (severity != null && severity.getOrdinal() > maxSeverity.getOrdinal()))
            {
                maxSeverity = severity;
            }
        }
        return maxSeverity;
    }

    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = 360065833137427239L;
}