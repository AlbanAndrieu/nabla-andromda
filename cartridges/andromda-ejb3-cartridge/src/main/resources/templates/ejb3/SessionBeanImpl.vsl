// license-header java merge-point
//
##// Generated by SessionBeanImpl.vsl in andromda-ejb3-cartridge on $umlUtils.date.
// Generated by SessionBeanImpl.vsl in andromda-ejb3-cartridge.
//
#if ($stringUtils.isNotBlank($service.packageName))
package $service.packageName;
#end
#set ($generatedFile = "${stringUtils.replace($service.fullyQualifiedServiceName,'.','/')}.java")

/**
 * @see ${service.fullyQualifiedServiceBaseName}
 *
 * Remember to manually configure the local business interface this bean implements if originally you only
 * defined the remote business interface.  However, this change is automatically reflected in the ejb-jar.xml.
 *
#if (!$service.seamComponent)
 * Do not specify the javax.ejb.${service.type} annotation
 * Instead, the session bean is defined in the ejb-jar.xml descriptor.
 */
@javax.ejb.${service.type}
#else
 * This session bean is a Seam component.  Currently, Seam components
 * must have the bean type specified via annotations.  Once this has been
 * fixed in Seam 1.2.1, it is enough to define the session bean
 * in ejb-jar.xml and we can safely remove this annotation.
 */
@javax.ejb.${service.type}
//Comment if using jboss embedded tests because it does not work with seam annotation
@org.jboss.seam.annotations.Scope(org.jboss.seam.ScopeType.${service.seamComponentScopeType})
@org.jboss.seam.annotations.Name("${service.seamComponentName}")
//@org.jboss.seam.annotations.intercept.Interceptors(org.jboss.seam.ejb.SeamInterceptor.class)
#**##if ($service.seamComponentStartup)
@org.jboss.seam.annotations.Startup#if ($stringUtils.isNotBlank($service.seamComponentStartupOptions))$service.seamComponentStartupOptions#end
#**##else
// Uncomment to define Seam startup
// @org.jboss.seam.annotations.Startup#if ($stringUtils.isNotBlank($service.seamComponentStartupOptions))$service.seamComponentStartupOptions#end

#**##end
#end
#if ($service.webServiceEnabled)
@javax.jws.WebService(endpointInterface = "${service.fullyQualifiedWebServiceInterfaceName}", serviceName = "${service.qName}")
#else
// Uncomment to enable webservices for ${service.serviceName}
// @javax.jws.WebService(endpointInterface = "${service.fullyQualifiedWebServiceInterfaceName}", serviceName = "${service.qName}")
#end
public class ${service.serviceName}## no new line
 extends ${service.fullyQualifiedServiceBaseName}## no new line
 implements#if ($service.viewTypeLocal) ${service.fullyQualifiedServiceLocalInterfaceName}#if ($service.viewTypeRemote),#end#end#if ($service.viewTypeRemote) ${service.fullyQualifiedServiceRemoteInterfaceName}#end

{
#if ($service.stateful)
    /**
     * Bean serial version ID
     */
    private static final long serialVersionUID = 1L;
#end

    // --------------- Constructors ---------------

## Default create method with no arguments.
    /**
     * Default constructor extending base class default constructor
     */
    public ${service.serviceName}()
    {
        super();
    }
#foreach ($operation in $service.getCreateMethods(false))

    /**
$operation.getDocumentation("     * ")
     */
    public ${service.serviceName}($operation.typedArgumentList)
    {
        // implementation
    }
#end
## Autogenerated create method with all attributes. Only present for stateful beans.
#set ($allAttributes = $service.allInstanceAttributes)
#if (!$allAttributes.empty)

    /**
     * Constructor with all attribute values.
#**##foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the ${attribute.name} property
#**##end
     */
    public ${service.serviceName}(${service.getAttributesAsList($allAttributes, true, true)})
    {
#**##if(!$allAttributes.empty)
        super($service.getAttributesAsList($allAttributes, false, true));
#**##end
    }
#end
#set ($operations = $service.businessOperations)
#if (!$operations.empty)

    // -------- Business Methods Impl --------------

#**##foreach ($operation in $operations)
#*  *##if (!$operation.lifecycleCallback)
    /**
#*    *##if ($operation.visibility == "public")
     * @see ${service.fullyQualifiedServiceBaseName}${esc.hash}${operation.getSignature(false)}
#*    *##else
$operation.getDocumentation("     * ")
#*    *##end
     */
#*    *##set ($abstract = $service.abstract && $operation.abstract)
#*    *##if ($operation.visibility == "public")
    protected## no newline
#*    *##else
    $operation.visibility##no newline
#*    *##end
#if ($abstract) abstract#end $operation.returnType.fullyQualifiedName $operation.implementationSignature## no new line
#*    *##if ($abstract)
 throws Exception;
#*    *##else
 throws Exception
    {
        //TODO: put your implementation here.
#*      *##if ($operation.returnTypePresent)
        // Dummy return value, just that the file compiles
        return $operation.returnType.javaNullString;
#*      *##else
        throw new UnsupportedOperationException("${service.fullyQualifiedServiceName}.${operation.implementationSignature} Not implemented!");
#*      *##end
    }
#*    *##end

#*  *##end
#**##end
#end
#if (!$operations.empty)

    // -------- Lifecycle Callback Implementation --------------

#**##foreach ($operation in $operations)
#*  *##if ($operation.lifecycleCallback)
    /**
     * @see ${service.fullyQualifiedServiceName}${esc.hash}${operation.name}()
     */
    protected void handle${stringUtils.capitalize(${operation.name})}()
    {
        // TODO put your lifecycle callback implementation here.
    }

#*  *##end
#**##end
#end
##if (${service.type}.equalsIgnoreCase('javax.ejb.Stateful'))
#if ($service.stateful)

    // ------------ Destroy Method ------------

    /**
     * Remove lifecycle method
     */
    @Override
#*  *##if ($service.seamComponent)
    @org.jboss.seam.annotations.Destroy
#*  *##end
    @javax.ejb.Remove
    public void destroy()
    {
        super.destroy();
    }
#end

}
