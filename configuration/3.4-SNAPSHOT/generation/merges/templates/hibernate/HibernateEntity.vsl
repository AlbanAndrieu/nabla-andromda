#set ($generatedFile = "${entity.packagePath}/${entity.entityName}.java")
// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: HibernateEntity.vsl in andromda-hibernate-cartridge.
//
#if ($stringUtils.isNotBlank($entity.packageName))
package $entity.packageName;
#end

//import javax.persistence.CascadeType;
//import javax.persistence.Column;
//import javax.persistence.Entity;
//import javax.persistence.GeneratedValue;
//import javax.persistence.Id;
//import javax.persistence.JoinColumn;
//import javax.persistence.JoinTable;
//import javax.persistence.ManyToMany;
//import javax.persistence.Table;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;

#if(!$entity.generalization)
import java.io.Serializable;

#end
/**
$entity.getDocumentation(" * ")
 */
//@Entity
//@Table(name = "$entity.tableName")
@XmlType(propOrder = {##no new line
#set ($comma = "")
#foreach ($attribute in $entity.attributes)
#if (!$attribute.identifier && (!$attribute.transient || $attribute.formula))
#set ($fullyQualifiedPropertyType = $attribute.type.fullyQualifiedHibernateType)
#if ($attribute.type.enumeration)
#set ($fullyQualifiedPropertyType = $attribute.type.fullyQualifiedHibernateEnumerationType)
#end
$comma"${attribute.name}"##no new line
#set ($comma = ", ")
#end
#end
})
@XmlAccessorType(XmlAccessType.FIELD)
public abstract class $entity.entityName##no new line
#if($entity.generalization)
 extends $entity.generalization.fullyQualifiedEntityImplementationName##no new line
#else
 implements Serializable##no new line
#if (!$entity.interfaceAbstractions.empty)
, $entity.implementedInterfaceList##no new line
#end
#end
{
    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = ${entity.serialVersionUID}L;

#if ($stringUtils.isNotBlank($entity.hibernateVersionProperty))
#if (!$entity.generalization || ($entity.generalization && !$entity.hibernateInheritanceSubclass))
#set ($versionProperty = $entity.hibernateVersionProperty)
#set ($versionPropertyCapitalized = $stringUtils.capitalize($entity.hibernateVersionProperty))
    /**
     * Version property managed by Hibernate.
     */
    private int $versionProperty;

    public int get$versionPropertyCapitalized()
    {
        return this.$versionProperty;
    }

    private void set$versionPropertyCapitalized (int ${versionProperty}In)
    {
        this.$versionProperty = ${versionProperty}In;
    }

#end
#end
#if($entity.compositeIdentifier)
#set($primaryKeyType="${entity.fullyQualifiedEntityName}PK")
#set($primaryKeyName="$stringUtils.uncapitalize($entity.name)Pk")
    @XmlTransient
    //@ManyToMany(cascade = CascadeType.PERSIST)
    //@JoinTable(name = "t_address_tag",
    //  joinColumns = {@JoinColumn(name = "address_fk")},
    //  inverseJoinColumns = {@JoinColumn(name = "tag_fk")})
    private $primaryKeyType $primaryKeyName;

    public $primaryKeyType get${entity.name}Pk()
    {
        return this.${primaryKeyName};
    }

    public void set${entity.name}Pk($primaryKeyType $primaryKeyName) {
        this.$primaryKeyName = $primaryKeyName;
    }

#end
#foreach ($attribute in $entity.attributes)
#if (!$entity.compositeIdentifier || ($entity.compositeIdentifier && !$attribute.identifier))
#set ($typeName = $attribute.getterSetterTypeName)
    //@Column(name = "${attribute.columnName}")
    @XmlElement(name = "${attribute.name}")
#if ($attribute.containsEmbeddedObject)
#set ($typeName = $attribute.type.fullyQualifiedEntityName)
    //@Id @GeneratedValue
    @XmlTransient    
#end
    private $typeName $attribute.name#if ($attribute.defaultValuePresent) = $attribute.defaultValue#end;

    /**
$attribute.getDocumentation("     * ")
     * @return this.${attribute.name} $typeName
     */
    $attribute.visibility $typeName ${attribute.getterName}()
    {
        return this.${attribute.name};
    }

    /**
$attribute.getDocumentation("     * ")
     * @param ${attribute.name}In ${typeName}
     */
    $attribute.visibility void ${attribute.setterName}(${typeName} ${attribute.name}In)
    {
        this.${attribute.name} = ${attribute.name}In;
    }

#end
#end
## Generate the associations
#foreach ($associationEnd in $entity.associationEnds)
#set ($target = $associationEnd.otherEnd)
#if ($target.navigable || ($associationEnd.child && $entity.foreignHibernateGeneratorClass))
#if ($target.many)
    private $target.getterSetterTypeName $target.name = $target.collectionTypeImplementation;
#else
    //@Column(name = "${target.columnName}", length = 10)
    @XmlElement(name = "${target.name}")
    private $target.getterSetterTypeName ${target.name};
#end

    /**
$target.getDocumentation("     * ")
     * @return this.${target.name} $target.getterSetterTypeName
     */
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }

    /**
$target.getDocumentation("     * ")
     * @param ${target.name}In $target.getterSetterTypeName
     */
    public void ${target.setterName}($target.getterSetterTypeName ${target.name}In)
    {
        this.${target.name} = ${target.name}In;
    }

#if ($target.many)
#if ($target.map)
    /**
$target.getDocumentation("     * ")
     * @param elementKey $target.collectionIndexType
     * @param elementToAdd $target.type.fullyQualifiedName
     * @return the previous value associated with <tt>key</tt>, or
     *         <tt>null</tt> if there was no mapping for <tt>key</tt>.
     *         (A <tt>null</tt> return can also indicate that the map
     *         previously associated <tt>null</tt> with <tt>key</tt>,
     *         if the implementation supports <tt>null</tt> values.)
     */
    public $target.type.fullyQualifiedName ${target.adderName}($target.collectionIndexType elementKey, $target.type.fullyQualifiedName elementToAdd)
    {
        return this.${target.name}.put(elementKey, elementToAdd);
    }

    /**
$target.getDocumentation("     * ")
     * @param elementKey $target.collectionIndexType
     * @return the previous value associated with <tt>key</tt>, or
     *         <tt>null</tt> if there was no mapping for <tt>key</tt>.
     */
    public $target.type.fullyQualifiedName ${target.removerName}($target.collectionIndexType elementKey)
    {
        return this.${target.name}.remove(elementKey);
    }
#else
    /**
$target.getDocumentation("     * ")
     * @param elementToAdd $target.type.fullyQualifiedName
     * @return <tt>true</tt> if this collection changed as a result of the
     *         call
     */
    public boolean ${target.adderName}($target.type.fullyQualifiedName elementToAdd)
    {
        return this.${target.name}.add(elementToAdd);
    }

    /**
$target.getDocumentation("     * ")
     * @param elementToRemove $target.type.fullyQualifiedName
     * @return <tt>true</tt> if this collection changed as a result of the
     *         call
     */
    public boolean ${target.removerName}($target.type.fullyQualifiedName elementToRemove)
    {
        return this.${target.name}.remove(elementToRemove);
    }
#end

#end
#end
#end
#foreach ($operation in $entity.businessOperations)
    /**
$operation.getDocumentation("     * ")
#if ($operation.exceptionsPresent)
    * @throws $operation.exceptionList
#end
     */
#if ($operation.exceptionsPresent)
    $operation.visibility abstract $operation.getterSetterReturnTypeName $operation.signature
        throws $operation.exceptionList;
#else
    $operation.visibility abstract $operation.getterSetterReturnTypeName $operation.signature;
#end

#end
#if ($generateEntityEqualsAndHashCode.equalsIgnoreCase('true'))
#set ($identifiers = $entity.getIdentifiers(false))
    /**
#if ($identifiers.empty)
     * This entity does not have any identifiers
#if ($entity.generalization)
     * but since it extends the <code>$entity.generalization.fullyQualifiedEntityImplementationName</code> class
     * it will simply delegate the call up there.
     *
     * @see ${entity.generalization.fullyQualifiedEntityName}${esc.hash}equals(Object)
#else
     * and is not extending any other entity,
     * so this method will only return <code>true</code> if the argument reference and <code>this</code>
     * refer to the same object.
#end
#else
#if ($entity.generalization)
     * Returns <code>true</code> if the argument is an $entity.entityName instance and all identifiers for this entity
     * equal the identifiers of the argument entity. The <code>equals</code> method of the parent entity
     * will also need to return <code>true</code>. Returns <code>false</code> otherwise.
     *
     * @see ${entity.generalization.fullyQualifiedEntityName}${esc.hash}equals(Object)
#else
     * Returns <code>true</code> if the argument is an $entity.entityName instance and all identifiers for this entity
     * equal the identifiers of the argument entity. Returns <code>false</code> otherwise.
#end
#end
     */
#renderEqualsMethod($entity $entity.entityName $identifiers)

    /**
#if ($identifiers.empty)
     * This entity does not have any identifiers
#if ($entity.generalization)
     * but since it extends the <code>$entity.generalization.fullyQualifiedEntityImplementationName</code> class
     * it will simply delegate the call up there.
     *
     * @see ${entity.generalization.fullyQualifiedEntityName}${esc.hash}hashCode()
#else
     * and is not extending any other entity,
     * so this method will only take the identifiers of this entity into account when calculating the hash code.
#end
#else
#if ($entity.generalization)
     * Returns a hash code based on this entity's identifiers and the hash code of the parent entity.
     *
     * @see ${entity.generalization.fullyQualifiedEntityName}${esc.hash}hashCode()
#else
     * Returns a hash code based on this entity's identifiers.
#end
#end
     */
#renderHashCodeMethod($entity $entity.entityName $identifiers)

#end
#if (!$entity.abstract)
    /**
     * Constructs new instances of {@link ${entity.fullyQualifiedName}}.
     */
    public static final class Factory
    {
        /**
         * Constructs a new instance of {@link ${entity.fullyQualifiedName}}.
         * @return new ${entity.fullyQualifiedEntityImplementationName}()
         */
        public static $entity.fullyQualifiedName newInstance()
        {
            return new ${entity.fullyQualifiedEntityImplementationName}();
        }

## Allow for the possibility that identifiers might be seen as required if default multiplicity is set to 1
#set ($allSize = $entity.allProperties.size())
#if (!$entity.usingForeignIdentifier)
## allRequiredProperties includes identifiers, which should never be required. subtract 1 from allProperties.size()
#foreach ($identifier in $entity.identifiers)
##// identifier $identifier
#set ($allSize = $allSize - 1)
#end
#end
#set ($requiredParams=0)
#foreach ($property in $entity.allRequiredConstructorParameters)
##// property $property
#if ($entity.usingForeignIdentifier || !$property.identifier)
#set ($requiredParams=$requiredParams+1)
#end
#end
## Don't duplicate newInstance if there are no optional parameters or no required parameters
#foreach ($property in $entity.allProperties)
##// allproperty $property
#end
##// ($entity.allRequiredConstructorParameters.size() + $entity.identifiers.size()) > $entity.allProperties.size()
##// $requiredParams $allSize $entity.allRequiredConstructorParameters.size() $entity.identifiers.size() $entity.allProperties.size()
// Don't use 3.4 or 3.3 use 3.2 vsl 
#if ( $requiredParams < $allSize && $requiredParams > 0 && ($entity.allRequiredConstructorParameters.size() + $entity.identifiers.size()) > $entity.allProperties.size())
        /**
         * Constructs a new instance of {@link ${entity.fullyQualifiedName}}, taking all required and/or
         * read-only properties as arguments, except for identifiers.
#foreach ($property in $entity.allRequiredConstructorParameters)
#if ($entity.usingForeignIdentifier || !$property.identifier)
         * @param ${property.name} ${property.getterSetterTypeName}
#end
#if ($property.identifier)
         * @param identifier ${property.name} ${property.getterSetterTypeName}
#end
#if ($entity.usingForeignIdentifier)
         * @param foreign ${property.name} ${property.getterSetterTypeName}
#end
#end
         * @return newInstance
         */
        public static $entity.fullyQualifiedName newInstance(## no newline
#set ($comma = "")
#foreach ($property in $entity.allRequiredConstructorParameters)
#set ($identifierPresent = false)
#foreach ($identifier in $entity.identifiers)
#if ($identifier == $property)
#set ($identifierPresent = true)
#end
#end
##if ($entity.usingForeignIdentifier || !$property.identifier)
#if ($entity.usingForeignIdentifier || (!$property.identifier || !${identifierPresent}) )
${comma}${property.getterSetterTypeName} ${property.name}## no newline
#set ($comma = ", ")
#end
#end
)
        {
            final ${entity.fullyQualifiedName} entityInstance = new ${entity.fullyQualifiedEntityImplementationName}();
#foreach ($property in $entity.allRequiredConstructorParameters)
#set ($identifierPresent = false)
#foreach ($identifier in $entity.identifiers)
#if ($identifier == $property)
##// identifier $identifier == $property
#set ($identifierPresent = true)
#end
#end
#if ($entity.usingForeignIdentifier || (!$property.identifier || !${identifierPresent}) )
            entityInstance.${property.setterName}(${property.name});
#end
#end
            return entityInstance;
        }
#end
#set ($propertiesPresent = false)
#foreach ($property in $entity.allProperties)
#if ($entity.usingForeignIdentifier || !$property.identifier)
#set ($propertiesPresent = true)
#end
#end
#if ($propertiesPresent)

        /**
         * Constructs a new instance of {@link ${entity.fullyQualifiedName}}, taking all possible properties
         * (except the identifier(s))as arguments.
#foreach ($property in $entity.allProperties)
#if ($entity.usingForeignIdentifier || !$property.identifier)
         * @param ${property.name} ${property.getterSetterTypeName}
#end
#end
         * @return newInstance $entity.fullyQualifiedName
         */
        public static $entity.fullyQualifiedName newInstance(## no newline
#set ($comma = "")
#foreach ($property in $entity.allProperties)
#if ($entity.usingForeignIdentifier || !$property.identifier)
${comma}${property.getterSetterTypeName} ${property.name}## no newline
#set ($comma = ", ")
#end
#end
)
        {
            final ${entity.fullyQualifiedName} entityInstance = new ${entity.fullyQualifiedEntityImplementationName}();
#foreach ($property in $entity.allProperties)
#if ($entity.usingForeignIdentifier || !$property.identifier)
            entityInstance.${property.setterName}(${property.name});
#end
#end
            return entityInstance;
        }
#end
    }

#end
// HibernateEntity.vsl merge-point
}