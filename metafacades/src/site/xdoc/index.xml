<?xml version="1.0" encoding="UTF-8"?>

<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

    <properties>
        <title>AndroMDA Metafacades</title>
        <!--
        <author email="mattes3@users.sourceforge.net">Matthias Bohlen</author>
        <author email="cwbrandon@users.sourceforge.net">Chad Brandon</author>
        -->
    </properties>

    <body>

        <section name="AndroMDA Metafacades">
            <p class="std">
                <strong>AndroMDA Metafacades</strong> are facades that are used
                to provide access to models loaded by a repository.  These 
                "metafacades" shield us from the underlying meta model implementation.
                Meta models are MOF modules such as UML 1.4, UML 2.0, etc.  Metafacades
                are generated by the <a href="../andromda-cartridges/andromda-meta-cartridge/index.html">andromda-meta-cartridge</a>.
            </p>
            <p>
                Metafacades (as explained below) are the object-oriented API that allows
                access to the model from within the templates. Using metafacades,
                the templates become much simpler and straightforward because
                the intelligence and responsibility for code transformation
                and generation is centralized in Java objects, not
                in the template script language.
            </p>
        </section>

        <section name="Introduction: The basics of metamodeling">
            <p> 
                The MOF repository instantiates a Java object for each element in your 
                model that you load into AndroMDA. The class of that object is 
                part of the UML metamodel. In MDA-speak, the instantiated graph
                of metamodel objects is called an "abstract syntax tree (AST)".
            </p>
            <p>
                Example: When you model the attribute of a class, an instance of 
                the metaclass "Attribute" is instantiated. The "birth:Date" attribute 
                of a model element "Person" will be instantiated as:
            </p>
            <ol>
                <li>
                    one object of class "Attribute" with 
                    its attribute "name" set to "birth"
                </li>
                <li>
                    one object of class "UMLClass" with its attribute 
                    "name" set to "Person" and a reference to the 
                    Attribute object that has the name "birth". 
                </li>
            </ol>
            <p>
                Look at this UML diagram to get the idea:
            </p>
            <img src="images/PersonExample.jpg" alt="images/PersonExample.jpg"/>
            <p>
                To see the complete UML metamodel, read 
                <a href="resources/UML14Metamodel.pdf">UML14Metamodel.pdf</a>.
                You will see the metamodel of UML 1.4, documented in UML itself.
                The "Attribute" class and all the other interesting metaclasses are 
                documented there.
            </p>
        </section>

        <section name="Metaclasses are 'data only'">
            <p> 
                Now that we have all these nice little AST objects representing our 
                model, we notice that they all have very little behavior - they 
                are just data holders for the metainformation from our model. It 
                would certainly be nice to attach behavior to them to support
                code generation. For example: 
                A <code>UMLClass</code> metaobject that represents an 
                <code><![CDATA[<<Entity>>]]></code> could validate itself and check 
                if it has at least one <code>Attribute</code> metaobject representing a 
                <code><![CDATA[<<Identifier>>]]></code> - this would be plain,
                clear and simple, right? 
                Now, why don't we simply write a class <code>EntityClass</code> that 
                extends the class <code>UMLClass</code>? Just like this:
            </p> 
<source><!--
public class EntityClass extends UMLClass {
    public void validate() throws ... {
        // throw exception here if PrimaryKey not found...
    }
}
--></source>
                <p>Another example:</p>
<source><!--
public class SpecialAttribute extends Attribute {
    public String getGetterName() {
        return "get" + uppercaseFirstLetter(getName());
    }
}
--></source>
            <p> 
                We could then use the class <code>SpecialAttribute</code> 
                instead of the class <code>Attribute</code> and write
                <code>$att.getterName</code> in our
                template script. The template engine would call the
                <code>getGetterName()</code> method shown above.
            </p> 
            <p> 
                Nice, object-oriented way to do something, right? Reality
                is not that simple, though. Keep on reading...
            </p> 
        </section>
        
        <section name="Classes that cannot be extended">
            <p> 
                Well, extending metaclasses would be nice, indeed! However, 
                there is no source or JAR file for those classes because 
                Netbeans MDR instantiates them on the fly through byte code 
                generation (absolutely magic!).  
            </p> 
            <p> 
                For those of you who want to see the magic, here are two
                interesting links into the MDR source files:
            </p>
            <ul> 
                <li><a href="http://mdr.netbeans.org/source/browse/mdr/src/org/netbeans/mdr/util/ImplGenerator.java">
                  ImplGenerator.java
                </a></li> 
                <li><a href="http://mdr.netbeans.org/source/browse/mdr/src/org/netbeans/mdr/handlers/MDRClassLoader.java">
                   MDRClassLoader.java
                </a></li>
            </ul>
            <p>
                So what can we do here? Since inheritance is impossible
                and the interface of a UML metaobject is quite complex,
                we use the GoF facade pattern and shield that complexity
                behind a quite lean interface that can easily be understood.
                We also abstract from the particular version of a metamodel
                (e.g. UML 1.4, UML 1.3, UML 2.0, etc.) because we want to be
                independent of them when we process input from different CASE
                tools.
                Enter metamodel facades, or "metafacades" for short!
            </p>
        </section>
        
        <section name="Metamodel facades = metafacades">
            <p>
                This picture shows you how the AndroMDA metamodel facades are 
                related to the metaclass interfaces and their implementation in 
                bytecode:
            </p>
            <img src="images/FacadePrinciples.jpg" alt="images/FacadePrinciples.jpg"/>
            <p>
                You can see that the facade hides the metaobject and
                enhances it with its own methods. The next figure shows
                how the templates interact with the metafacades and how
                the metafacades inside a cartridge relate to the basic
                metafacades that ship with the AndroMDA distribution (in
                the subdirectory "metafacades"):
            </p>
            <img src="images/FacadeLayer.jpg" alt="images/FacadeLayer.jpg"/>
            <p>
                Templates within a cartridge call metafacades. Those can
                be contained in the same cartridge or in the base metafacades
                package. The base metafacades define common interfaces for
                metafacades and implement these interfaces in
                separate classes which are specific for a certain version of
                the metamodel (UML in this case, but any metamodel like CWM, etc. will do).
            </p>
        </section>

        <section name="Almost a real world example: EJB metafacades">
            <p>
                Metafacades carry behavior that supports code generation.
                The following picture shows you a concrete example for this:
                operations of metafacades used for EJB code generation.
            </p>
            <img src="images/EJBFacades.jpg" alt="images/EJBFacades.jpg"/>
            <p>
                At the top of the diagram, you see a simplified version of
                the base metafacade <code>ClassifierFacade</code>. (By the way:
                Classifier is a metamodel superclass of UMLClass). You see
                that this facade supports a <code>getFullyQualifiedName()</code> method
                which is handy for templates: A template can invoke this method
                using the <code>$class.fullyQualifiedName</code> syntax. 
            </p>
            <p>
                You can also see the method <code>getAttributesAsList()</code>.
                This method returns a string that can be used for generating
                superclass constructor calls or <code>ejbCreate()</code> calls.
                For a class with attributes <code>a</code>
                and <code>b</code>, the method returns <code>"(a, b)"</code>.
            </p>
        </section>

        <section name="Using metafacades from a template">
            <p>
                Now, how would a template look like that uses these
                metafacades? Let's have a look at a template from the EJB
                cartridge which generates an entity bean. There is a section
                in the template that generates business methods into the
                bean class - I omit a lot of complexity here and reduce it
                to the essence of method generation:
            </p>
<source><!--
#foreach ( $operation in $class.operations)
#set ($visibility = $operation.visibility)
#set ($returnType = $operation.returnType.fullyQualifiedName)
#if ($operation.hasExceptions())
    $visibility abstract $returnType $operation.signature
        throws $operation.exceptionList;
#else
    $visibility abstract $returnType $operation.signature;
#end
--></source>
            <p>
                In this template code sample, you can see that the variable <code>$op</code>
                iterates over a collection called <code>$class.operations</code>. When the
                template engine processes the <code>foreach</code> statement, it calls the
                <code>ClassifierFacade.getOperations()</code> method which corresponds
                directly to the aggregation <code>operations</code> that you see in the
                UML diagram above. So, <code>$op</code> is now of type
                <code>OperationFacade</code>.
            </p>
            <p>
                The next expression that the template engine evaluates is
                <code>$op.signature</code>. This invokes the method
                <code>OperationFacade.getSignature()</code>. The facade for
                operations contains quite a bit of code inside this method
                as it collects all parameters of the operation, extracts
                their type and their name and concatenates them, using
                comma as a separator.
            </p>
            <p>
                Last example: The most interesting statement in the code snippet
                above is:
            </p>
<source><!--
#set ($returnType = $op.returnType.fullyQualifiedName)
--></source>
            <p>
                This template engine invokes two methods, here:
                <code>OperationFacade.getReturnType()</code> and
                <code>ClassifierFacade.getFullyQualifiedName()</code>. Plain,
                clear and simple, right? Well, it's really simple except that
                the description in this paragraph contains a few simplifying lies :-)
                but continue to read and you will see what I mean...                
            </p>
        </section>

        <section name="Where to go from here">
            <p>
                If you followed the text until here, you will want to
                write metafacades for your own cartridge. In that case, 
                you will most likely have (at least) these questions in mind: 
            </p>
            <ul>
                <li>How do I create a metafacade class?</li>
                <li>Where do I put it in the source code tree?</li>
                <li>How do I make AndroMDA instantiate it at the right time?</li>
                <li>Do I have to rewrite my metafacades each time I use a different
                    version of UML?</li>
            </ul>
            <p>
                OK, I admit that only smart people will have the last question
                in mind but I guess you're smart, right? So, please read the
                next chapters <a href="developing.html">Developing metafacades</a>
                to see how to create them and
                <a href="configuring.html">Configuring metafacades</a>
                to make AndroMDA use them at the right time.
            </p>
        </section>

    </body>
</document>
